<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="在路上的coder博客 Java | Redis | JVM | Python ..."><title>JVM运行机制介绍 | 在路上的coder</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM运行机制介绍</h1><a id="logo" href="/.">在路上的coder</a><p class="description">Coder,Machine Learning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM运行机制介绍</h1><div class="post-meta">Oct 7, 2017</div><div class="post-content"><h2 id="JVM运行机制"><a href="#JVM运行机制" class="headerlink" title="JVM运行机制"></a>JVM运行机制</h2><p>该文主要介绍：<strong>JVM启动流程</strong> 、<strong>JVM基本结构</strong> 、 <strong>JVM的内存模型</strong> 、<strong>编译运行和解释运行的区别</strong> 通过这几部份来了解和学习JVM。</p>
<a id="more"></a>
<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java version:1.6.0_45</div><div class="line">os:Linux centos6</div></pre></td></tr></table></figure>
<h3 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h3><p>JVM的启动流程如下：</p>
<p><img src="http://opzxa0ul7.bkt.clouddn.com/jvm启动流程.jpg" alt="jvm启动流程"></p>
<p>通过<code>java</code> 命令执行某个class文件，通过jvm.cfg文件装载对应的配置信息，通过配置查找JVM.dll文件初始化JVM，找到<code>main</code> 方法运行。</p>
<h3 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h3><p>JVM的主要结构如下：</p>
<p><img src="http://opzxa0ul7.bkt.clouddn.com/JVM基本结构.jpg" alt="JVM基本结构"></p>
<p>我们主要关心的是：方法区、Java堆、Java栈和PC寄存器。下面将依次介绍</p>
<h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><ul>
<li>每个线程拥有一个PC寄存器</li>
<li>在线程创建时 创建</li>
<li>指向下一条指令的地址</li>
<li>执行本地方法时，PC寄存器地址的值为undefined</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>保存类的元信息<ul>
<li>类型的常量池</li>
<li>字段、方法信息</li>
<li>方法字节码</li>
</ul>
</li>
<li>通常和永久区(Perm)关联在一起</li>
<li><font color="red">注意点 </font><ul>
<li>JDK6中，String常量信息置于方法中；JDK7中，已经移动到堆中</li>
</ul>
</li>
</ul>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul>
<li>和程序开发密切相关</li>
<li>应用系统对象保存在Java堆中</li>
<li>所有线程共享Java堆</li>
<li>对分代GC来说，堆也是分代的</li>
<li>GC的主要工作空间</li>
</ul>
<h4 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h4><ul>
<li>线程私有</li>
<li>栈由一系列帧组成</li>
<li>帧保存一个方法的局部变量、操作数栈、常量池指针</li>
<li>每一次方法调用创建一个栈、并压栈</li>
</ul>
<p>局部变量表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStatic</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">long</span> l,<span class="keyword">float</span> f,Object o,<span class="keyword">byte</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">runInstance</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">short</span> s,<span class="keyword">boolean</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>静态方法对应的局部变量表如下</strong>：</p>
<table>
<thead>
<tr>
<th>0 int int i</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 long long l</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>3 float float f</td>
</tr>
<tr>
<td>4 reference Object o</td>
</tr>
<tr>
<td>5 int byte b</td>
</tr>
</tbody>
</table>
<p>这里long 类型占用两个字节，Object 类型的变量只是一个引用</p>
<p><strong>实例方法对应的局部变量表如下</strong>：</p>
<table>
<thead>
<tr>
<th>0 reference this</th>
</tr>
</thead>
<tbody>
<tr>
<td>1   int   char   c</td>
</tr>
<tr>
<td>2   int   short   s</td>
</tr>
<tr>
<td>3   int   boolean   b</td>
</tr>
</tbody>
</table>
<p>基本和静态方法一致，只是局部变量表的第一个参数表示的是当前对象的引用</p>
<p><strong>函数调用组成帧栈</strong></p>
<p>通过下段代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStatic</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">long</span> l,<span class="keyword">float</span> f,Object o,<span class="keyword">byte</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> runStatic(i,l,f,o,b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码是一个递归调用，而且是没有退出条件，最后结果就是栈溢出，下面的图片显示了调用三次的栈帧示例</p>
<p><img src="http://opzxa0ul7.bkt.clouddn.com/栈帧示例.jpg" alt="栈帧示例"></p>
<p><strong>操作数栈</strong></p>
<p>Java没有寄存器，所有参数传递使用操作数栈实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">    c = a + b;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>翻译后</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0:  iconst_0 // int常量0压栈</div><div class="line">1:  istore_2 // 弹出int，存放在本地变量2，这里变量2表示c</div><div class="line">2:  iload_0 // 把局部变量0压栈，局部变量0表示a</div><div class="line">3:  iload_1 // 把局部变量1压栈，局部变量1表示b</div><div class="line">4:  iadd // 弹出2两个变量，就是结果压栈</div><div class="line">5:  istore_2 // 弹出结果，放入局部变量2中</div><div class="line">6:  iload_2 // 局部变量2压栈</div><div class="line">7:  ireturn // 返回</div></pre></td></tr></table></figure>
<p><img src="http://opzxa0ul7.bkt.clouddn.com/操作数栈例子.jpg" alt="操作数栈例子"></p>
<p><strong>栈上分配</strong></p>
<p>下面通过一段代码来演示栈上分配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnStackTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</div><div class="line">        b[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> b=System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123;</div><div class="line">            alloc();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> e=System.currentTimeMillis();</div><div class="line">        System.out.println(e-b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC OnStackTest</div></pre></td></tr></table></figure>
<p>执行返回结果为 <code>42</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -server -Xmx10m -Xms10m -XX:-DoEscapeAnalysis -XX:+PrintGC OnStackTest</div></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[GC 2624K-&gt;192K(9856K), 0.0006780 secs]</div><div class="line">[GC 2816K-&gt;160K(9856K), 0.0006150 secs]</div><div class="line">[GC 2784K-&gt;160K(9856K), 0.0005490 secs]</div><div class="line">[GC 2784K-&gt;160K(9856K), 0.0005980 secs]</div><div class="line">[GC 2784K-&gt;160K(9856K), 0.0003480 secs]</div><div class="line">[GC 2784K-&gt;160K(10048K), 0.0003390 secs]</div><div class="line">[GC 3168K-&gt;124K(9920K), 0.0010710 secs]</div><div class="line">[GC 3132K-&gt;124K(9984K), 0.0001650 secs]</div><div class="line">[GC 3004K-&gt;124K(9984K), 0.0001340 secs]</div><div class="line">[GC 3004K-&gt;124K(9984K), 0.0001420 secs]</div><div class="line">[GC 3004K-&gt;124K(9792K), 0.0001190 secs]</div><div class="line">...</div><div class="line">1035</div></pre></td></tr></table></figure>
<p>第一个命令表示是栈上分配，第二个命令表示在堆上分配</p>
<ul>
<li>小对象(一般几十比特)，在没有逃逸的情况下，可以直接分配在栈上；ps：逃逸对象指，当变量（或者对象）在方法中分配后，其指针被返回或者被全局引用（这样就会被其他过程或者线程所引用），这种现象称作指针（或者引用）的逃逸(Escape)</li>
<li>直接分配在栈上，可以自动回收，减少GC压力</li>
<li>大对象或者逃逸对象无法栈上分配</li>
</ul>
<p><strong>栈、堆、方法区交互</strong></p>
<p>通过下图和代码块来描述栈、堆、方法区的交互</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span>  <span class="title">AppMain</span>     </span></div><div class="line"> //运行时, <span class="title">jvm</span> 把<span class="title">appmain</span>的信息都放入方法区</div><div class="line">&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span>   <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span>  </span></div><div class="line"><span class="comment">//main 方法本身放入方法区。 </span></div><div class="line">  &#123;</div><div class="line">    Sample test1 = <span class="keyword">new</span>  Sample( <span class="string">" 测试1 "</span> );  </div><div class="line"> <span class="comment">//test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面 </span></div><div class="line">    Sample test2 = <span class="keyword">new</span>  Sample( <span class="string">" 测试2 "</span> );</div><div class="line">    test1.printName(); </div><div class="line">    test2.printName(); </div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span>  <span class="title">Sample</span>       </span></div><div class="line"> //运行时, <span class="title">jvm</span> 把<span class="title">appmain</span>的信息都放入方法区 </div><div class="line">&#123; <span class="keyword">private</span>  name;     </div><div class="line"> <span class="comment">//new Sample实例后， name 引用放入栈区里，  name 对象放入堆里 </span></div><div class="line"> <span class="function"><span class="keyword">public</span>  <span class="title">Sample</span><span class="params">(String name)</span> </span></div><div class="line"> &#123; </div><div class="line">   <span class="keyword">this</span> .name = name; </div><div class="line"> &#125; <span class="comment">//print方法本身放入 方法区里。</span></div><div class="line"> <span class="function"><span class="keyword">public</span>   <span class="keyword">void</span>  <span class="title">printName</span><span class="params">()</span>    </span></div><div class="line"> &#123; </div><div class="line">   System.out.println(name); </div><div class="line"> &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://opzxa0ul7.bkt.clouddn.com/栈堆方法区交互.jpg" alt="栈堆方法区交互"></p>
<p>执行main方法的Sample对象的引用是放在main方法的栈中，对象本身是在堆中创建，在创建对象时需要读取方法区的类的元数据信息。</p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>内存模型</p>
<ul>
<li>每一个线程有一个工作内存和主内存独立</li>
<li>工作内存存放主内存中变量的值得拷贝</li>
</ul>
<p>当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作</p>
<p>每一个操作都是原子的，即执行期间不会被中断。也就是read操作是原子的，但是read和load操作之间是可以暂停的</p>
<p>对于普通变量，一个线程中更新的值，不能马上反应在其他变量中</p>
<p>如果需要在其他线程中立即可见，需要使用 volatile 关键字</p>
<p>具体如下图：</p>
<p><img src="http://opzxa0ul7.bkt.clouddn.com/JVM内存模型.jpg" alt="JVM内存模型"></p>
<h4 id="volatile关键字介绍"><a href="#volatile关键字介绍" class="headerlink" title="volatile关键字介绍"></a>volatile关键字介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileStopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span></span>&#123;</div><div class="line">  stop=<span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(!stop)&#123;</div><div class="line">          i++;</div><div class="line">      &#125;</div><div class="line">    System.out.println(<span class="string">"Stop thread"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">      VolatileStopThread t=<span class="keyword">new</span> VolatileStopThread();</div><div class="line">      t.start();</div><div class="line">      Thread.sleep(<span class="number">1000</span>);</div><div class="line">      t.stopMe();</div><div class="line">      Thread.sleep(<span class="number">1000</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>volatile 不能代替锁</p>
<p>一般认为volatile 比锁性能好（不绝对）</p>
<p>选择使用volatile的条件是：满足某个线程的依赖另外线程的对共享变量的修改</p>
<h4 id="内存模型相关的概念"><a href="#内存模型相关的概念" class="headerlink" title="内存模型相关的概念"></a>内存模型相关的概念</h4><ul>
<li>可见性<ul>
<li>一个线程修改了共享变量，其他线程可以立即知道</li>
</ul>
</li>
<li>保证可见性的方法<ul>
<li>volatile 关键字</li>
<li>synchronized 关键字</li>
<li>final 关键字 (一旦初始化完成，其他线程可见)</li>
</ul>
</li>
<li>有序性<ul>
<li>在本线程内，操作都是有序的</li>
<li>在线程外观察，操作都是无序的。(导致原因：指令重排或主内存同步延迟)</li>
</ul>
</li>
<li>指令重排<ul>
<li>线程内串行语义<ul>
<li>写后读 <code>a=1;b=a;</code> 写一个变量后，再读这个变量</li>
<li>写后写 <code>a=1;a=2;</code> 写一个变量后，再写这个变量</li>
<li>读后写 <code>a=b;b=1;</code>读完一个变量后，在写这个变量</li>
<li>以上语句<font color="red">不可</font>重排</li>
<li>编译器不考虑多线程的语义</li>
<li>可重排语句：a=1;b=2;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>指令重排 —— 破坏线程间的有序性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    a = <span class="number">1</span>;                   </div><div class="line">    flag = <span class="keyword">true</span>;           </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (flag) &#123;                </div><div class="line">        <span class="keyword">int</span> i =  a +<span class="number">1</span>;      </div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行流程：</p>
<p>线程A首先执行writer()方法</p>
<p>线程B线程接着执行reader()方法</p>
<p>线程B在int i=a+1 是不一定能看到a已经被赋值为1</p>
<p>因为在writer中，两句话顺序可能打乱</p>
<p><strong>指令重排 —— 保证有序性的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    a = <span class="number">1</span>;                   </div><div class="line">    flag = <span class="keyword">true</span>;           </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (flag) &#123;                </div><div class="line">        <span class="keyword">int</span> i =  a +<span class="number">1</span>;      </div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步后，即使做了writer重排，因为互斥的缘故，reader 线程看writer线程也是顺序执行的。</p>
<p><strong>指令重排的基本原则</strong></p>
<ul>
<li>程序顺序原则：一个线程内保证语义的串行性</li>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性：A先于B，B先于C 那么A必然先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结（Thread.join()）</li>
<li>线程的中断（interrupt()）先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
</ul>
<h3 id="编译运行和解释运行的区别"><a href="#编译运行和解释运行的区别" class="headerlink" title="编译运行和解释运行的区别"></a>编译运行和解释运行的区别</h3><ul>
<li>解释运行<ul>
<li>解释执行以解释方式运行字节码</li>
<li>解释执行的意思是：读一句执行一句</li>
</ul>
</li>
<li>编译运行（JIT）<ul>
<li>将字节码编译成机器码</li>
<li>直接执行机器码</li>
<li>运行时编译</li>
<li>编译后性能有数量级的提升</li>
</ul>
</li>
</ul>
<h3 id="jdk6下载地址"><a href="#jdk6下载地址" class="headerlink" title="jdk6下载地址"></a>jdk6下载地址</h3><p><a href="https://pan.baidu.com/s/1i4YLjBR" target="_blank" rel="external">点击下载</a></p>
</div><div class="tags"><a href="/tags/JVM/">JVM</a><a href="/tags/JVM运行机制介绍/">JVM运行机制介绍</a></div><div class="post-nav"><a class="pre" href="/2017/10/08/JVM常用配置参数/">JVM常用配置参数</a><a class="next" href="/2017/09/30/初识Java和JVM/">初识Java和JVM</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/JMS/" style="font-size: 15px;">JMS</a> <a href="/tags/Spring-Boot自动配置详解/" style="font-size: 15px;">Spring Boot自动配置详解</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC参数介绍/" style="font-size: 15px;">GC参数介绍</a> <a href="/tags/学习视频/" style="font-size: 15px;">学习视频</a> <a href="/tags/JVM算法与种类/" style="font-size: 15px;">JVM算法与种类</a> <a href="/tags/JVM参数配置/" style="font-size: 15px;">JVM参数配置</a> <a href="/tags/Java架构师之路/" style="font-size: 15px;">Java架构师之路</a> <a href="/tags/JVM运行机制介绍/" style="font-size: 15px;">JVM运行机制介绍</a> <a href="/tags/Java集合源码/" style="font-size: 15px;">Java集合源码</a> <a href="/tags/ArrayList源码/" style="font-size: 15px;">ArrayList源码</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a> <a href="/tags/UML时序图/" style="font-size: 15px;">UML时序图</a> <a href="/tags/HashMap源码/" style="font-size: 15px;">HashMap源码</a> <a href="/tags/Java工具类源码/" style="font-size: 15px;">Java工具类源码</a> <a href="/tags/NumberUtils使用介绍/" style="font-size: 15px;">NumberUtils使用介绍</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Spring-IOC源码/" style="font-size: 15px;">Spring IOC源码</a> <a href="/tags/Spring-IOC工作流程/" style="font-size: 15px;">Spring IOC工作流程</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/nosql/" style="font-size: 15px;">nosql</a> <a href="/tags/缓存/" style="font-size: 15px;">缓存</a> <a href="/tags/idea/" style="font-size: 15px;">idea</a> <a href="/tags/idea快捷键/" style="font-size: 15px;">idea快捷键</a> <a href="/tags/ActiveMQ安装/" style="font-size: 15px;">ActiveMQ安装</a> <a href="/tags/js正则表达式/" style="font-size: 15px;">js正则表达式</a> <a href="/tags/电话号码正则表达式/" style="font-size: 15px;">电话号码正则表达式</a> <a href="/tags/邮箱正则表达式/" style="font-size: 15px;">邮箱正则表达式</a> <a href="/tags/maven配置/" style="font-size: 15px;">maven配置</a> <a href="/tags/maven配置远程仓库/" style="font-size: 15px;">maven配置远程仓库</a> <a href="/tags/maven配置编译级别/" style="font-size: 15px;">maven配置编译级别</a> <a href="/tags/Python高级语法/" style="font-size: 15px;">Python高级语法</a> <a href="/tags/python3/" style="font-size: 15px;">python3</a> <a href="/tags/python入门/" style="font-size: 15px;">python入门</a> <a href="/tags/redis主从复制/" style="font-size: 15px;">redis主从复制</a> <a href="/tags/redis安装/" style="font-size: 15px;">redis安装</a> <a href="/tags/redis集群添加节点/" style="font-size: 15px;">redis集群添加节点</a> <a href="/tags/redis集群水平扩展/" style="font-size: 15px;">redis集群水平扩展</a> <a href="/tags/redis持久化/" style="font-size: 15px;">redis持久化</a> <a href="/tags/redis哨兵模式/" style="font-size: 15px;">redis哨兵模式</a> <a href="/tags/redis集群/" style="font-size: 15px;">redis集群</a> <a href="/tags/redis集群移除节点/" style="font-size: 15px;">redis集群移除节点</a> <a href="/tags/Spring-AOP使用/" style="font-size: 15px;">Spring AOP使用</a> <a href="/tags/Spring4/" style="font-size: 15px;">Spring4</a> <a href="/tags/JVM和JDK介绍/" style="font-size: 15px;">JVM和JDK介绍</a> <a href="/tags/java爬取今日头条文章/" style="font-size: 15px;">java爬取今日头条文章</a> <a href="/tags/java爬虫/" style="font-size: 15px;">java爬虫</a> <a href="/tags/http请求过程，/" style="font-size: 15px;">http请求过程，</a> <a href="/tags/DNS解析过程/" style="font-size: 15px;">DNS解析过程</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/JVM监控处理工具/" style="font-size: 15px;">JVM监控处理工具</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/SpringBoot集成ES/">SpringBoot集成ES</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/08/ElasticSearch高级查询/">ElasticSearch高级查询</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/ElasticSearch入门/">ElasticSearch入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/04/python高级语法与用法/">python3高级语法与用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/13/python3基础和进阶/">python3基础和进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/Boot自动配置实战/">Spring Boot自动配置实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/11/spring中AOP的使用/">Spring中AOP的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/OO与UML/">OO与UML</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/虚拟机性能监控和处理工具/">虚拟机性能监控和处理工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/16/类装载器/">类装载器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ifeve.com/" title="并发编程网" target="_blank">并发编程网</a><ul></ul><a href="http://blog.csdn.net/facekbook" title="CSDN博客" target="_blank">CSDN博客</a><ul></ul><a href="http://coolshell.cn/" title="酷客" target="_blank">酷客</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰博客" target="_blank">阮一峰博客</a><ul></ul><a href="http://www.jiuzhang.com/" title="九章算法" target="_blank">九章算法</a><ul></ul><a href="http://www.lintcode.com/zh-cn/" title="LintCode" target="_blank">LintCode</a><ul></ul><a href="https://www.ibm.com/developerworks/cn/" title="developerWorks" target="_blank">developerWorks</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">在路上的coder.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>